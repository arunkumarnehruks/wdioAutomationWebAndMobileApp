import { deepmerge } from 'deepmerge-ts';
import logger from '@wdio/logger';
import { remote, multiremote, attach } from 'webdriverio';
import { DEFAULTS } from 'webdriver';
import { DEFAULT_CONFIGS } from '@wdio/config';
const log = logger('@wdio/runner');
/**
 * sanitizes wdio config from capability properties
 * @param  {Object} caps  desired session capabilities
 * @return {Object}       sanitized caps
 */
export function sanitizeCaps(caps, filterOut) {
    const defaultConfigsKeys = [
        // WDIO config keys
        ...Object.keys(DEFAULT_CONFIGS()),
        // WebDriver config keys
        ...Object.keys(DEFAULTS)
    ];
    return Object.keys(caps).filter((key) => (
    /**
     * filter out all wdio config keys
     */
    !defaultConfigsKeys.includes(key) === !filterOut)).reduce((obj, key) => {
        obj[key] = caps[key];
        return obj;
    }, {});
}
/**
 * initialise browser instance depending whether remote or multiremote is requested
 * @param  {Object}  config        configuration of sessions
 * @param  {Object}  capabilities  desired session capabilities
 * @param  {boolean} isMultiremote isMultiremote
 * @return {Promise}               resolves with browser object
 */
export async function initialiseInstance(config, capabilities, isMultiremote) {
    /**
     * check if config has sessionId and attach it to a running session if so
     */
    if (config.sessionId) {
        log.debug(`attach to session with id ${config.sessionId}`);
        config.capabilities = sanitizeCaps(capabilities);
        /**
         * propagate connection details defined by services or user in capabilities
         */
        const caps = capabilities;
        const connectionProps = {
            protocol: caps.protocol || config.protocol,
            hostname: caps.hostname || config.hostname,
            port: caps.port || config.port,
            path: caps.path || config.path
        };
        return attach({ ...config, ...connectionProps, capabilities });
    }
    if (!isMultiremote) {
        log.debug('init remote session');
        const sessionConfig = {
            ...config,
            ...sanitizeCaps(capabilities, true),
            capabilities: sanitizeCaps(capabilities)
        };
        return remote(sessionConfig);
    }
    const options = {};
    log.debug('init multiremote session');
    // @ts-expect-error ToDo(Christian): can be removed?
    delete config.capabilities;
    for (const browserName of Object.keys(capabilities)) {
        options[browserName] = deepmerge(config, capabilities[browserName]);
    }
    const browser = await multiremote(options, config);
    /**
     * only attach to global environment if `injectGlobals` is set to true
     */
    const browserNames = config.injectGlobals ? Object.keys(capabilities) : [];
    for (const browserName of browserNames) {
        // @ts-ignore allow random global browser names
        global[browserName] = browser[browserName];
    }
    return browser;
}
/**
 * Filter logTypes based on filter
 * @param  {string[]} excludeDriverLogs logTypes filter
 * @param  {string[]} driverLogTypes    available driver log types
 * @return {string[]}                   logTypes
 */
export function filterLogTypes(excludeDriverLogs, driverLogTypes) {
    let logTypes = [...driverLogTypes];
    if (Array.isArray(excludeDriverLogs)) {
        log.debug('filtering logTypes', logTypes);
        logTypes = excludeDriverLogs.length === 1 && excludeDriverLogs[0] === '*'
            ? []
            : logTypes.filter(x => !excludeDriverLogs.includes(x)); // exclude specific logTypes
        log.debug('filtered logTypes', logTypes);
    }
    return logTypes;
}
/**
 * Gets { sessionId, isW3C, protocol, hostname, port, path, queryParams } of every Multiremote instance
 * @param {object} browser browser
 * @param {boolean} isMultiremote isMultiremote
 * @return {object}
 */
export function getInstancesData(browser, isMultiremote) {
    if (!isMultiremote) {
        return;
    }
    const multiRemoteBrowser = browser;
    const instances = {};
    multiRemoteBrowser.instances.forEach((browserName) => {
        const { protocol, hostname, port, path, queryParams } = multiRemoteBrowser.getInstance(browserName).options;
        const { isW3C, sessionId } = multiRemoteBrowser.getInstance(browserName);
        instances[browserName] = { sessionId, isW3C, protocol, hostname, port, path, queryParams };
    });
    return instances;
}
